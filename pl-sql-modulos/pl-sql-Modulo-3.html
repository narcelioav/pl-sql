IFRS - Instituto Federal Rio Grande do Sul

Banco de Dados: Oracle PL/SQL - Turma 2025B

MODULO 3 - Exception, Package e Trigger

<pre>
3.1 Exception
Quando um erro ocorre na execução de um bloco PL/SQL o Oracle dispara uma exceção. Por exemplo, se utilizamos a cláusula INTO em um SELECT e este retornar mais de uma linha será gerada uma exceção chamada TOO_MANY_ROWS.  Se o SELECT INTO não retornar nenhuma linha a exceção gerada será NO_DATA_FOUND. Também é possível gerar uma exceção utilizando o comando RAISE. Esta execeção poderá ser tratada na seção EXCEPTION e assim o erro não será propagado para o programa principal.

Exemplo:

DECLARE
    v_salario NUMBER;
    p_id NUMBER;
BEGIN
  p_id:= 100;

  SELECT salario
  INTO v_salario
  FROM funcionario
  WHERE id_departamento=p_id;

  DBMS_OUTPUT.PUT_LINE('Salario: '||v_salario);

END;

Erro: Quando o bloco foi executado o Oracle gerou uma exceção (TOO_MANY_ROWS) e apresentou a seguinte mensagem de erro pois o departamento 100 tem vários funcionários. Lembrando que a cláusula INTO só pode ser utilizada se o SELECT retornar apenas uma linha.

ORA-01422: exact fetch returns more than requested number of rows ORA-06512: at line 7 ORA-06512: at "SYS.DBMS_SQL", line 1721
</pre>

<pre>
  3.1.1 RAISE_APPLICATION_ERROR
A procedure RAISE_APPLICATION_ERROR permite que o programador crie uma mensagem de erro específica para seu programa. O primeiro argumento é um valor entre -20999 e -20000, o segundo argumento é a mensagem de erro.

Vamos ver um exemplo.

Exemplo: Procedure que recebe como parâmetro o id_departamento e apresenta na tela o total de funcionários deste departamento.

CREATE OR REPLACE PROCEDURE func_depto(p_id IN NUMBER) IS
  v_total NUMBER;
BEGIN
 IF p_id<(esse sinal deu divergencia ...)0
 THEN RAISE_APPLICATION_ERROR(-20300,'Valor inválido');
 END IF;
 
SELECT COUNT(*)
 INTO v_total
 FROM funcionario
 WHERE id_departamento=p_id;

 DBMS_OUTPUT.PUT_LINE('Departamento '||p_id||': '||v_total|| ' funcionários');
END;

Executando a procedure com id_departamento 100
EXEC func_depto(100);

Saída no Oracle Live
Statement processed.

Departamento 100: 2 funcionários

Executando a procedure com id_departamento -10
ORA-20300: Valor inválido ORA-06512: at "SQL_ENIEZAZTOGSJZMMEAEZWXPCOS.FUNC_DEPTO", line 5 ORA-06512: at line 1 ORA-06512: at "SYS.DBMS_SQL", line 1721

Explicando o código e a chamada da procedure
A procedure func_depto recebe como parâmetro o número do departamento. No início da procedure foi colocado um comando de seleção que chama a procedure RAISE_APLICATION_ERROR se o valor informado para o id_departamento for negativo. Neste caso será apresentada a mensagem Valor inválido.

</pre>

<pre>
  3.1.2 EXCEPTION NO_DATA_FOUND
Considere uma procedure que recebe como parâmetro o id_funcionario e apresenta na tela o nome do funcionario.

CREATE OR REPLACE PROCEDURE nome_func(p_id IN NUMBER) IS
v_nome funcionario.nome_funcionario%type;
BEGIN
 
  SELECT nome_funcionario
  INTO v_nome
  FROM funcionario
  WHERE id_funcionario=p_id;

  DBMS_OUTPUT.PUT_LINE('Funcionário: '||v_nome);

 EXCEPTION
 WHEN NO_DATA_FOUND
 THEN
   DBMS_OUTPUT.PUT_LINE('Funcionário não existe');
END;

Chamando a procedure com id de funcionário igual a 4
exec nome_func(4);

Saída no Oracle Live
Statement processed.

Funcionário: Maria

Chamando a procedure com id de funcionário igual a 9
O funcionário 9 não existe no banco de dados.

exec nome_func(9);

Saída no Oracle Live
Como a exceção foi tratada no bloco Exception (When NO_DATA_FOUND) não será gerado um erro apenas a mensagem do PUT_LINE.

Statement processed.

 Funcionário não existe

Vamos ver mais um exemplo agora  sem tratamento da exceção NO_DATA_FOUND.

CREATE OR REPLACE PROCEDURE nome_func(p_id IN NUMBER) IS
v_nome funcionario.nome_funcionario%type;
BEGIN
 
  SELECT nome_funcionario
  INTO v_nome
  FROM funcionario
  WHERE id_funcionario=p_id;

  DBMS_OUTPUT.PUT_LINE('Funcionário: '||v_nome);

END;

Chamando a procedure com id de funcionário igual a 9
O funcionário 9 não existe no banco de dados.

exec nome_func(9);

Saída no Oracle Live
Como a exceção não foi tratada o erro foi gerado.

ORA-01403: no data found ORA-06512: at "SQL_ENIEZAZTOGSJZMMEAEZWXPCOS.NOME_FUNC", line 5 ORA-06512: at line 1 ORA-06512: at "SYS.DBMS_SQL", line 1721

</pre>

<pre>
  3.2 Package
Um package é objeto que agrupa logicamente um ou mais PROCEDURE e FUNCTION, varáveis, cursores, tipos de dados, entre outros. Um package e possui duas partes: a especificação e o corpo. Na especificação são declaradas as varáveis, tipos, o cabeçalho das procedures e functions. No corpo (package body) fica o código das procedures e functions.

Exemplo: Package com uma função que retorna o total de funcionários da empresa e uma procedure que retorna em um parâmetro de saída os dados de todos os funcionários da empresa.

Passo1: Criar a especificação do pacote

 create or replace package pkg_func is //pkg é o nome do package
 function cont_func return number; //só o cabeçalho da funçãosem o corpo (implementação)
 procedure get_func (res out sys_refcursor); // só o cabeçalho da procedure sem o corpo
 end;

 O sys_refcursor é utilizado quando o parametro ou variavel irá conter um conjunto de linhas. Ele pode ser utilizado em qualquer objeto PL/SQL e não apenas em packages.

Atenção: aqui não vai o create or replace antes da procedure ou function apenas antes do package.


Figura 1- Especificação do pacote

Passo2: Criar o corpo do pacote.

  Função que retorna o total de funcionarios da empresa. Não colocar create or replace antes do nome da função pois ela está sendo declarada dentro da package.

  create or replace package body pkg_func as // nome da package
  function cont_func return number is 
  v_total number;
  begin
  select count(*)
  into v_total
  from funcionario;

  return v_total;
  end cont_func;

  Procedure que retorna no parametro de saida res dos dados de todos os funcionarios da empresa. Não colocar create or replace antes do nome da procedure pois ela está sendo declarada dentro do pacote.

  procedure get_func (res out sys_refcursor) is 
  begin
  open res for select * from funcionario;
  end get_func;
  end pkg_func;

Figura 2 - Criação do corpo do pacote

Passo 3: Executar a procedure que está definida dentro do pacote.

 var v_res refcursor;
 exec pkg_func.get_func(:v_res);
 print v_res;

 Declaração da variavel no sql developer do tipo refcursor. A variavel v_res vai receber uma ou n linhas é um recordset.

 Para executar a procedure get_func é necessario primeiro colocar o nome do pacote e depois um ponto seguido do nome da procedure.

Figura 3 - Execução da procedure



Obs: A única diferença de executar  procedures e functions que estão definidas dentro de um package é que no comando de execução o nome do package deve ser colocado antes do nome da procedure ou function exec pkg_func.get_func (:v_res);

Para eliminar um pacote é utilizado o comando DROP PACKAGE.
</pre>

<pre>
  3.3 Trigger
Os triggers são similares a procedures e functions, são blocos PL/SQL com a diferença de que a procedure é executada explicitamente através de uma chamada e o trigger é disparado implicitamente através de eventos DML (INSERT, UPDATE, DELETE) sobre as tabelas do BD ou eventos start database, shutdown database, login e logoff de usuário.

As triggers podem ser criadas para: 

    DML statements (DELETE, INSERT, UPDATE)

    DDL statements (CREATE, ALTER, DROP)

    Database operations (SERVERERROR, LOGON, LOGOFF, STARTUP, SHUTDOWN)



Sintaxe
CREATE [OR REPLACE] TRIGGER trigger_name

{before|after|intead of} triggering_event  [OF <atributo>,..,<atributo>] ON

table_reference

[FOR EACH ROW [WHEN trigger_condition]]

[DECLARE]

trigger_body;

DROP TRIGGER triggername;

ALTER TRIGGER triggername {Disable|Enable}



Elementos importantes em uma trigger
O que dispara a trigger: comando DML pode disparar  a trigger INSERT, UPDATE, DELETE.

Tempo: BEFORE ou AFTER, define quando a trigger será dispara antes (BEFORE) ou depois (AFTER) da execução do comando (statement).

Nível: trigger a nível de linha (com a cláusula FOR EACH ROW). Se a trigger for criada com esta cláusula significa que se o comando que disparou a trigger, por exemplo, um update em uma tabela, atualizar 5 linhas a trigger será executada 5 vezes, uma para cada update. Se a trigger for criada sem esta cláusula mesmo que o update arualize 5 linhas a trigger será disparada apenas uma vez. Importante: Só triggers que tem a cláusula FOR EACH ROW podem fazer referência aos valores :new e :old.

Exemplo1: Trigger que verifica se o salário atribuído aos funcionário está dentro dos limites estabelecidos para o cargo (atributos min_sal e max_sal da tabela cargo). 

CREATE OR REPLACE TRIGGER Verifica_Salario
BEFORE
INSERT OR UPDATE OF id_cargo, salario
ON Funcionario
FOR EACH ROW
DECLARE
isal NUMBER;
xsal NUMBER;
BEGIN
  SELECT min_sal, max_sal
  INTO isal, xsal
  FROM Cargo
  WHERE id_cargo = :new.id_cargo;
 
  IF (:new.salario < isal OR :new.salario > xsal)
  THEN raise_application_error(-20601,
   'Salario fora dos limites estabelecidos para o cargo');
  END IF;
     EXCEPTION
   WHEN no_data_found THEN
         NULL; 
END;


Como disparar a trigger
Diferente das procedures e functions que são chamadas através dos comandos exec, execute, call ou sendo chamada dentro de um bloco PL/SQL anônimo. A trigger é disparada quando um determinado evento acontece. Neste exemplo um insert ou update envolvendo os atributos id_cargo e salario na tabela funcionario (INSERT OR UPDATE OF id_cargo, salario ON Funcionario).

O seguinte comando vai disparar a execução da trigger:
insert into funcionario(id_funcionario, nome_funcionario, salario, id_departamento, id_cargo)
values (100, 'Ana', 3000, 1, 2);

O insert será executado com sucesso se o valor do salário 3000 (:new.salario) estiver entre o menor e o maior valor para o id_cargo 2 (:new.id_cargo) na tabela cargo.
Substituindo os valores :new da trigger para o insert acima o select executado seria o seguinte:

  SELECT min_sal, max_sal
  INTO isal, xsal
  FROM Cargo
  WHERE id_cargo = 2;

E o comando IF:
  IF (3000 < isal OR 3000 > xsal)

O Cláusula FOR EACH ROW antes do DECLARE é necessária pois a TRIGGER faz referência a valor :new dos campos id_cargo e salario.
</pre>

<pre>
  3.3.1 Mutating Table
Existem algumas restrições sobre as tabelas que podem ser utilizadas no corpo de código da trigger.

Considere o seguinte exemplo: Trigger que não permite que o departamento tenha mais do que 4 funcionários. 

CREATE OR REPLACE TRIGGER N_Func
BEFORE
INSERT OR UPDATE OF id_departamento
ON Funcionario
FOR EACH ROW
DECLARE
v_cont NUMBER;
BEGIN
     SELECT count(*)
     INTO v_cont
     FROM Funcionario
     WHERE id_departamento = :new.id_departamento;
   
 IF (v_cont  +1 > 3)
    THEN raise_application_error(-20601,'Muitos funcionario');
  END IF;
 END;



Explicando o código
Esta trigger será disparada quando for realizado um insert na tabela funcionario ou um update do atributo di_departamento na tabela funcionario (BEFORE INSERT OR UPDATE OF id_departamento).

Na corpo da trigger é realizada uma consulta  (SELECT count(*) ...) na tabela funcionario para verificar a quantidade de funcionários do departamento que utilizado no comando que disparou a trigger (:new.id_departamento). A quantidade de funcionários deste departamento será atribuída a variável v_cont (INTO v_cont). 

 Se a quantidade de funcionários + 1 for maior do que 3 a operação será abortada e o registro não será inserido ou atualizado.



O comando update a seguir dispara a trigger
update funcionario
set id_departamento =100 
where id_funcionario in (1,2,3); 



Erro
ORA-04091: table SQL_SQGILVYKTXWJQPAIBGJFDBEKU.FUNCIONARIO is mutating, trigger/function may not see it ORA-06512: at "SQL_SQGILVYKTXWJQPAIBGJFDBEKU.N_FUNC", line 4 ORA-06512: at "SYS.DBMS_SQL", line 1721

O erro aconteceu porque a table funcionário é a tabela mutante pois está sendo alterada em um comando DML e no corpo da trigger temos uma consulta nesta tabela (SELECT count(*) ... FROm funcionario). Este erro não aconteceria se a trigger não fosse a nível de linha FOR EACH ROW.
</pre>

<pre>
  3.3.2 Mutating Table - Como resolver o problema
Como resolver o problema de Mutating Table

Solução 1
Utilizar a cláusula PRAGMA AUTONOMOUS_TRANSACTION.

CREATE OR REPLACE TRIGGER N_Func
BEFORE
INSERT OR UPDATE OF id_departamento
ON Funcionario
FOR EACH ROW
DECLARE
v_cont NUMBER;
PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
     SELECT count(*)
     INTO v_cont
     FROM Funcionario
     WHERE id_departamento = :new.id_departamento;
    
IF (v_cont  +1 > 3)
THEN raise_application_error(-20601,'Muitos funcionario');
END IF;
    END;




Solução 2
Criar duas triggers uma a nível de linha (FOR EACH ROW) e outra a nível de statament (sem a cláusula FOR EACH ROW).


CREATE OR REPLACE PACKAGE FuncData AS
TYPE t_departamento IS TABLE OF Funcionario.id_departamento%Type
  INDEX BY BINARY_INTEGER;
TYPE t_funcionario IS TABLE OF Funcionario.id_funcionario%TYPE
  INDEX BY BINARY_INTEGER;
    v_funcionario    t_funcionario;
    v_departamento   t_departamento;
    v_cont            NUMBER := 0;
END;

CREATE OR REPLACE TRIGGER RNfunc
  BEFORE INSERT OR UPDATE OF id_departamento ON Funcionario
  FOR EACH ROW
BEGIN
   FuncData.v_cont := FuncData.v_cont + 1;
   FuncData.v_departamento(FuncData.v_cont ) := :new.id_departamento;
   FuncData.v_funcionario(FuncData.v_cont) := :new.id_funcionario;
END;

 CREATE OR REPLACE TRIGGER SNFunc
  AFTER INSERT OR UPDATE OF id_departamento ON Funcionario
DECLARE
   V_cont             NUMBER;
   V_total             NUMBER;
   V_id_funcionario   Funcionario.id_funcionario%TYPE;
   V_id_departamento  Funcionario.id_departamento%TYPE;
BEGIN
    V_total := FuncData.v_cont;
    FuncData.v_cont := 0;
 
    FOR v_loopIndex IN 1..v_total LOOP
       V_id_departamento  := FuncData.v_departamento(v_loopIndex);
       V_id_funcionario   := FuncData.v_funcionario(v_loopIndex);
      
       SELECT COUNT(*)
       INTO v_cont
       FROM funcionario
       WHERE id_departamento = v_id_departamento;
 
       IF v_cont > 3 THEN  
 RAISE_APPLICATION_ERROR(-20011, 'Muitos funcionario no departamento’ || v_id_departamento || ' por causa do funcionario ' || v_id_funcionario);
       END IF;
    END LOOP;
END;



Solução 3 (apenas a partir do Oracle 11g)
Compound trigger. Na mesma trigger pode ter um trecho de statament level e outro row level.

CREATE OR REPLACE TRIGGER trg_func
FOR INSERT OR UPDATE OF id_departamento ON Funcionario
COMPOUND TRIGGER
TYPE t_departamento IS TABLE OF Funcionario.id_departamento%Type
INDEX BY BINARY_INTEGER;
TYPE t_funcionario IS TABLE OF Funcionario.id_funcionario%TYPE INDEX BY BINARY_INTEGER;
v_funcionario t_funcionario;
v_departamento t_departamento; v_cont NUMBER := 0;
V_total NUMBER; V_id_funcionario Funcionario.id_funcionario%TYPE;
V_id_departamento Funcionario.id_departamento%TYPE;
BEFORE EACH ROW IS
BEGIN
v_cont := v_cont + 1;
v_departamento(v_cont ) := :new.id_departamento;
v_funcionario(v_cont) := :new.id_funcionario;
END BEFORE EACH ROW;
AFTER STATEMENT IS
BEGIN
V_total := v_cont;
v_cont := 0;
FOR v_loopIndex IN 1..v_total LOOP 
V_id_departamento :=  v_departamento(v_loopIndex);
V_id_funcionario := v_funcionario(v_loopIndex);
 SELECT COUNT(*)
INTO v_cont
FROM funcionario 
WHERE id_departamento = v_id_departamento;
IF v_cont > 3 THEN
RAISE_APPLICATION_ERROR(-20011, 'Muitos funcionario no departamento’ || v_id_departamento || ' por causa do funcionario ' || v_id_funcionario); 
END IF; 
END LOOP; 
END AFTER STATEMENT; 
END; 
</pre>

<pre>
  3.4 Desafio 5
Alterar a tabela funcionário e incluir o campo data_admissão. Fazer uma trigger que não permite que seja inserido/alterado a data de admissão para um valor maior que a data de hoje.
</pre>

<pre>
  3.4.1 Solução do Desafio 5
alter table funcionario add data_admissao date;

CREATE OR REPLACE TRIGGER verifica_data
BEFORE
INSERT OR UPDATE OF data_admissao
ON Funcionario
FOR EACH ROW
BEGIN
 if :new.data_admissao > sysdate
 then  
       raise_application_error(-20601,   'Data inválida');
  end if;
END;

Explicando o código:

O comando alter table altera a tabela funcionário incluindo o campo data_admissao.

A trigger verifica_data será disparada quando for executado um insert ou update do atributo data_admissao na tabela funcionario.

Se a data inserida ou atualizada (:new.data_admissao) for maior que a data de hoje (sysdate) a comando DML (insert ou update) não será executado com sucesso raise_application_error.
</pre>

<pre>
  3.5 Desafio 6
Criar uma trigger que gera um log de todas as alterações da tabela cargo.
</pre>

<pre>
  3.5.1 Solução do Desafio 6
Solução do Desafio:

create table log_cargo
(
NEW_ID_CARGO NUMBER,
OLD_ID_CARGO NUMBER,
NEW_NOME_CARGO VARCHAR2(10),
OLD_NOME_CARGO VARCHAR2(10),
NEW_MIN_SAL NUMBER,
OLD_MIN_SAL NUMBER,
NEW_MAX_SAL NUMBER,
OLD_MAX_SAL NUMBER,
OPERACAO VARCHAR2(1),
USUARIO VARCHAR2(10),
DATA_HORA DATE

);
CREATE OR REPLACE TRIGGER Tr_Log_cargo
AFTER INSERT OR UPDATE OR DELETE
ON Cargo
FOR EACH ROW
DECLARE
v_op varchar2(1);
BEGIN
IF INSERTING THEN
v_op:='I';
ELSIF UPDATING THEN
v_op:='U';
ELSE
v_op:='D';
END IF;

insert into log_cargo
(new_id_cargo,old_id_cargo,new_nome_cargo,old_nome_cargo,new_min_sal,old_min_sal,new_max_sal,old_max_sal,operacao,usuario,data_hora)
values (:new.id_cargo,:old.id_cargo,:new.nome_cargo,:old.nome_cargo,:new.min_sal,:old.min_sal,:new.max_sal,:old.max_sal,v_op,user,sysdate);

END;

Explicando o código:
  Inicialmente é criada a tabela log_cargo para armazar o log da tabela cargo. A tabela log_cargo possui o new  e o old de cada campo da tabela cargo. Por exemplo, se for inserido o cargo gerente. O campo new_nome_cargo vai ter o valor gerente e o campo old_nome_cargo vai ser null pois o insert não tem valores old para os campos. Se o nome do cargo gerente fosse alterado para gerente de vendas seria inserido um registro na tabela log_cargo com o valor gerente de vendas para o campo new_nome_cargo e o valore gerente para o campo old_nome_cargo.
O comando if com os predicados inserting, updating é utilizado para que possa ser criada apenas uma trigger para os três comandos DML. Se a trigger for disparada por causa de um comando INSERT por exemplo, o predicado INSERTING será verdadeiro e a variável v_op vai receber o valor I. Isto significa que o registro no log vai receber o valor I indicando que que a operação realizada na tabela cargo foi um insert.
No comando insert da trigger são inseridos os valores inseridos, alterados ou excluídos da tabela cargo. A função sysdate retorna a data e hora atual e a função uuser retorna o usuário que executou o comando DML na tabela cargo.

Testando o Log:
Executar o comando insert na tabela cargo

insert into cargo values(305,'gerente',5000,9000);

Quando o comando insert é executado a trigger Tr_Log_cargo será disparada e um registro referente a operação de insert na tabela cargo será inserido na tabela log_cargo.

Uma consulta na tabela Log_cargo apresenta as seguintes informações:
SELECT * 
FROM log_cargo;

NEW_ID_CARGO

OLD_ID_CARGO

NEW_NOME_CARGO

OLD_NOME_CARGO

NEW_MIN_SAL

OLD_MIN_SAL

NEW_MAX_SAL

OLD_MAX_SAL

OPERACAO

USUARIO

DATA_HORA

305

-

gerente

-

5000

-

9000

-

I

APEX_PUBLIC_USER

13-SEP-23
</pre>
