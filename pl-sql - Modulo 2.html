IFRS - Instituto Federal Rio Grande do Sul

Banco de Dados: Oracle PL/SQL - Turma 2025B

MODULO 2

<pre>
2.1 Procedure
Uma procedure é um bloco PL/SQL que possui um nome e uma vez  criada é compilada e fica armazenado no Banco de Dados. Como a procedure fica armazenada no banco de dados, ela pode ser chamada de um programa de aplicação escrito em Python, Java, PHP ou outra linguagem.

A procedure é criada com os comandos CREATE PROCEDURE ou CREATE OR REPLACE PROCEDURE. 

Uma procedure pode ter um ou mais comandos DML - [Departamento Médico-Legal],[Depósito de Material de Limpeza] Data Manipulation Language (insert, update e delete) e um ou mais comandos SELECT.

A utilização de procedures possui os seguintes benefícios:

Segurança
Maior desempenho
Manutenção                                                                                                                                                                                                                                  
Comando para criar uma procedure

CREATE OR REPLACE PROCEDURE <nome da procedure> [(<variavel> IN <tipo> , <variavel> OUT <tipo>,...., <variavel> IN OUT <tipo>)] IS
[ <variavel> <tipo>,
    ......
   <variavel> <tipo>
]
BEGIN
     <comandos PL_SQL>
END;

﻿Atenção: Pode-se utilizar commit e rollback dentro das procedures/functions.


Importante: A procedure pode ser criada apenas com o create procedure. A utilização do comando create or replace significa que se procedure não existe ela será criada e se já existir é substituída. Em ambiente de desenvolvimento pode-se utilizar o create or replace mas em ambiente de produção recomenda-se utilizar create procedure. 



Comando para eliminar uma procedure
DROP PROCEDURE <nome>;

Exemplo: Criar uma procedure que insere 10 registros na tabela funcionário.

CREATE OR REPLACE PROCEDURE carga IS
  v_i NUMBER(6);
  v_sal NUMBER(6) := 1000;
BEGIN
 FOR v_i IN 1..10 LOOP
 Insert into funcionario(id_funcionario, nome_funcionario,salario, id_departamento, id_cargo) 
    values(sfuncionario.nextval,'Pedro'||v_i,v_sal,100,300);
  v_sal := v_sal + 100;
END LOOP;
 END;

Explicação:

O trecho de código acima é semelhante ao apresentado no módulo anterior quando criamos um bloco PL/SQL anônimo para inserir 10 linhas na tabela funcionário. A diferença está no CREATE OR REPLACE PROCEDURE CARGA que dá um nome ao bloco PL/SQL neste caso, carga. Sendo assim, a procedure será compilada e armazenada no banco de dados e poderá ser chamado posteriormente.

Como chamar a procedure carga: 

1. Utilizando o Execute
 EXECUTE carga;

2. Utilizando o Exec
        EXEC carga;

3. Utilizando o Call
 Call carga();

4. Utilizando um bloco PL/SQL anônimo
Begin
  Carga;
End;
</pre>

<pre>
  2.1.1 Parâmetros
Parâmetros
Uma procure pode ter um ou mais parâmetros Os parâmetros podem ser:

IN – parâmetro de entrada (é o padrão). Significa que o valor é passado ao parâmetro e não pode ser alterado.

OUT – parâmetro de saída.  Significa que um valor pode ser atribuído ao parâmetro na procedure e retornado ao programa principal.

IN OUT -  parâmetro de entrada e saída. Significa que um valor pode ser passado e retornado pelo parâmetro.

Observação: Se o IN e OUT não forem utilizados na declaração do parâmetro indica que ele é um parâmetro de entrada (IN).
Exemplo: Alterar a procedure carga para receber um parâmetro de entrada que é o número de linhas que devem ser inseridas na tabela funcionario.

CREATE OR REPLACE PROCEDURE carga(v_linhas IN NUMBER) IS
  v_i NUMBER(6);
  v_sal NUMBER(6) := 1000;
BEGIN
 FOR v_i IN 1..v_linhas LOOP
     insert into funcionario(id_funcionario, nome_funcionario,salario, id_departamento, id_cargo) 
      values(sfuncionario.nextval,'Pedro'||v_i,v_sal,100,300);
     v_sal := v_sal + 100;
 END LOOP;
END;

O parâmetro v_linhas do tipo NUMBER é utilizado no comando FOR v_i IN 1..v_linhas para determinar o número de repetições no laço de repetição FOR e consequentemente o número de linhas que serão inseridas na tabela funcionário.

Na chamada do procedimento o valor 4 é passado para o parâmetro v_linhas. Isso indica que serão inseridas 4 linhas na tabela funcionario.

--Chamada da procedure

EXEC carga(4);
</pre>

<pre>
2.1.2 Parâmetro do tipo OUT
O parâmetro do tipo OUT permite que um valor seja atribuído ao parâmetro dentro da PROCEDURE e retorne ao bloco que chamou a PROCEDURE.

Exemplo: Procedure que retorna em um parâmetro de saída o número de linhas da tabela funcionario.

CREATE OR REPLACE PROCEDURE conta_funcionarios(p_total OUT NUMBER) IS
BEGIN
  SELECT count(*)
  INTO p_total
  FROM funcionario;
END;

Explicando o código:

O parâmetro p_total é utilizado na cláusula INTO e recebe o número de linhas da tabela funcionário. O select utiliza a função de agregação count para contar o número de linhas da tabela funcionário.

Para chamar a PROCEDURE é utilizado um bloco PL/SQL anônimo. A procedure PUT_LINE imprime na tela o texto Número de linhas da tabela funcionario: e o conteúdo da variável num que recebeu o retorno do parâmetro p_total da PROCEDURE conta_funcionarios.

DECLARE
  num NUMBER;
BEGIN
  conta_funcionarios(num);
  DBMS_OUTPUT.PUT_LINE('Número de linhas da tabela funcionario:'||num);
END;
</pre>

<pre>
  2.2 Desafio 2

Desafio: Criar uma procedure que recebe como parâmetro o nome do departamento e verifica o número de funcionários deste departamento apresentando a seguinte mensagem:
0 – O departamento não possui funcionários
1-20 – Classificação – Departamento Pequeno
21-30 – Classificação – Departamento Médio
31 ou mais – Classificação – Departamento Grande
</pre>

<pre>

  Solução 1:

Solução do Desafio:
CREATE OR REPLACE PROCEDURE verifica_depto (p_nome IN VARCHAR2) IS
   v_cont NUMBER;
BEGIN
SELECT count(*)
INTO v_cont
FROM funcionario f inner join departamento d
on f.id_departamento = d.id_departamento
WHERE d.nome_departamento = p_nome;

IF v_cont =0
THEN DBMS_OUTPUT.PUT_LINE('O departamento não possui funcionários');
ELSIF v_cont <=20
THEN DBMS_OUTPUT.PUT_LINE('Departamento Pequeno');
ELSIF v_cont <=30
THEN DBMS_OUTPUT.PUT_LINE('Departamento Médio');
ELSE DBMS_OUTPUT.PUT_LINE('Departamento Grande');
END IF;
END;


Explicando o código:

  A PROCEDURE recebe como parâmetro o nome no departamento. Para descobrir o total de funcionários do departamento é necessário fazer um JOIN entre as tabelas funcionario e departamento pois a informação de que funcionário trabalha em qual departamento está na tabela funcionário e o nome do departamento está na tabela departamento. O número de funcionários no departamento é atribuído a variável v_cont através do INTO.

O comando de seleção IF é utilizado para determinar o que será impresso na tela dependendo do conteúdo da variável v_cont.

Na declaração do parâmetro p_nome não pode ser colocado o tamanho VARCHAR2(30) como é feito na declaração de variáveis. 

CREATE OR REPLACE PROCEDURE verifica_depto (p_nome IN VARCHAR2(30)) IS

A declaração acima retornaria um erro sintático.


Chamada da procedure:

EXEC verifica_depto ('Vendas');

-----------------------------------------------------------------------------------------

  Solução 2:

1. Recebe o nome do departamento como parâmetro de entrada.

2. Conta quantos funcionários estão nesse departamento.

3. Exibe uma mensagem conforme a faixa de quantidade.

  Versão da procedure com parâmetro IN

CREATE OR REPLACE PROCEDURE verifica_departamento(p_nome_departamento IN VARCHAR2) IS
    v_qtd_funcionarios NUMBER;
BEGIN
    -- Conta quantos funcionários existem nesse departamento
    SELECT COUNT(f.id_funcionario)
      INTO v_qtd_funcionarios
      FROM funcionario f
      JOIN departamento d ON f.id_departamento = d.id_departamento
     WHERE UPPER(d.nome_departamento) = UPPER(p_nome_departamento);

    -- Exibe a classificação conforme o número de funcionários
    IF v_qtd_funcionarios = 0 THEN
        DBMS_OUTPUT.PUT_LINE('O departamento não possui funcionários');
    ELSIF v_qtd_funcionarios BETWEEN 1 AND 20 THEN
        DBMS_OUTPUT.PUT_LINE('Classificação – Departamento Pequeno (' || v_qtd_funcionarios || ' funcionários)');
    ELSIF v_qtd_funcionarios BETWEEN 21 AND 30 THEN
        DBMS_OUTPUT.PUT_LINE('Classificação – Departamento Médio (' || v_qtd_funcionarios || ' funcionários)');
    ELSE
        DBMS_OUTPUT.PUT_LINE('Classificação – Departamento Grande (' || v_qtd_funcionarios || ' funcionários)');
    END IF;

EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('Departamento não encontrado.');
END;

Para testar:

SET SERVEROUTPUT ON;
EXEC verifica_departamento('Vendas');

A procedure compara o nome do departamento sem diferenciar maiúsculas/minúsculas (UPPER()).

Se o nome não existir na tabela departamento, o tratamento de exceção mostra a mensagem “Departamento não encontrado.”

É importante que as tabelas funcionario e departamento estejam relacionadas pela coluna id_departamento.

-----------------------------------------------------------------------------------------

Solução 3:

Ajustar a procedure para que, além de mostrar no console (DBMS_OUTPUT.PUT_LINE), ela também retorne a classificação como valor de saída, através de um parâmetro OUT.

Versão da procedure com parâmetro OUT

CREATE OR REPLACE PROCEDURE verificar_departamento(
    p_nome_departamento IN VARCHAR2,
    p_classificacao OUT VARCHAR2
) IS
    v_qtd_funcionarios NUMBER;
BEGIN
    -- Conta o número de funcionários do departamento informado
    SELECT COUNT(f.id_funcionario)
      INTO v_qtd_funcionarios
      FROM funcionario f
      JOIN departamento d ON f.id_departamento = d.id_departamento
     WHERE UPPER(d.nome_departamento) = UPPER(p_nome_departamento);

    -- Define o texto da classificação
    IF v_qtd_funcionarios = 0 THEN
        p_classificacao := 'O departamento não possui funcionários';
    ELSIF v_qtd_funcionarios BETWEEN 1 AND 20 THEN
        p_classificacao := 'Classificação - Departamento Pequeno (' || v_qtd_funcionarios || ' funcionários)';
    ELSIF v_qtd_funcionarios BETWEEN 21 AND 30 THEN
        p_classificacao := 'Classificação - Departamento Médio (' || v_qtd_funcionarios || ' funcionários)';
    ELSE
        p_classificacao := 'Classificação - Departamento Grande (' || v_qtd_funcionarios || ' funcionários)';
    END IF;

    -- Exibe também na saída
    DBMS_OUTPUT.PUT_LINE(p_classificacao);

EXCEPTION
    WHEN NO_DATA_FOUND THEN
        p_classificacao := 'Departamento não encontrado.';
        DBMS_OUTPUT.PUT_LINE(p_classificacao);
END;

SET SERVEROUTPUT ON;
VARIABLE v_resultado VARCHAR2(200);

EXEC verificar_departamento('Vendas', :v_resultado);

PRINT v_resultado;

A procedure recebe o nome do departamento (p_nome_departamento).

Calcula quantos funcionários há nele.

Define a mensagem de classificação e grava no parâmetro OUT (p_classificacao).

Também mostra a mensagem no console com DBMS_OUTPUT.
</pre>

<pre>
  2.3 Desafio 3

Desafio:  Criar um procedimento que recebe como parâmetro o id do funcionário e retorna em um parâmetro de saída o cargo do funcionário.
</pre>

<pre>
  2.3.1 Solução do Desafio 3
Solução do Desafio:

CREATE OR REPLACE PROCEDURE retorna_cargo
(p_id_funcionario IN funcionario.id_funcionario%type,
p_cargo OUT cargo.nome_cargo%type)
IS
BEGIN
SELECT nome_cargo
INTO p_cargo
FROM funcionario f inner join cargo c
on f.id_cargo = c.id_cargo
WHERE f.id_funcionario = p_id_funcionario;
END;

Explicando o código:
A procedure recebe um parâmetro de entrada p_id_funcionario que é do mesmo tipo da coluna id_funcionario da tabela funcionario mas este parâmetro também poderia ser definido como sendo do tipo NUMBER. O outro parâmetro é um parâmetro de saída (OUT) do mesmo tipo da coluna nome_cargo da tabela cargo mas também poderia ser definido como VARCHAR2.

O SELECT faz um JOIN entre as tabelas funcionario (id_funcionario) e a tabela cargo (nome do cargo do funcionario).

O parâmetro OUT p_cargo recebe o nome do cargo na cláusula  INTO p_cargo (comando SELECT).

Chamada da procedure: 

DECLARE
  v_nome VARCHAR2(30);
BEGIN
  retorna_cargo(1,v_nome);
  DBMS_OUTPUT.PUT_LINE('Cargo do funcionário:'||v_nome);
END;

Na chamada da procedure retorna_cargo(1,v_nome), o parâmetro 1 é o id do funcionário. A variável v_nome vai receber o nome do cargo do funcionário retornado pelo parâmetro p_cargo. O put_line imprime na tela o texto Cargo do funcionário: e o conteúdo da variável v_nome.
</pre>

<pre>
  2.4 Function
Uma function é um outro tipo de bloco PL/SQL que diferente da procedure retorna um valor na sua chamada. No código da function deve ser definido o valor e o tipo de dado que será retornado. Assim como a procedure, uma function pode ou não ter parâmetros.

Uma function pode ter um ou mais comandos DML (insert, update e delete) e um ou mais comandos SELECT.

Exemplo: Função que retorna a soma de salários de um determinado departamento, o id do departamento deve ser passado como parâmetro.
CREATE OR REPLACE FUNCTION soma_salarios(p_id IN NUMBER)
    RETURN NUMBER IS
 soma NUMBER;
BEGIN

  SELECT sum(salario)
  INTO soma
  FROM funcionario
  where id_departamento = p_id;

RETURN soma;
END;

Explicando o código: Na declaração da função é necessário colocar o tipo de dados que será retornado. Neste exemplo o retorno será do tipo numérico RETURN NUMBER. O RETURN é colocado depois da declaração dos parâmetros da função.

A soma dos salários é atribuída a variável soma no INTO soma do comando SELECT.

O RETURN soma antes do END da function retorna a soma dos salários para o bloco que chamou a função.

Chamada da função:

DECLARE
  total NUMBER;
BEGIN
  total := soma_salarios(100);
  DBMS_OUTPUT.PUT_LINE('Soma dos salários do departamento:'||total);
END;

Como a function retorna um valor na sua chamada, a chamada da função deve ser atribuída a uma variável, total := soma_salarios(100);

O conteúdo da variável total é apresentado na tela no comando put_line.
</pre>

<pre>
  2.5 Desafio 4

  Desafio: Criar uma função que recebe como parâmetro o nome do funcionário e retorna em um parâmetro de saída o nome do departamento deste funcionário.
</pre>

<pre>
  2.5.1 Solução do Desafio 4
Solução do Desafio:

CREATE OR REPLACE FUNCTION retorna_departamento (p_nome IN VARCHAR2) RETURN VARCHAR2
IS
v_depto VARCHAR2(30);   
BEGIN
SELECT nome_departamento
INTO v_depto
FROM funcionario f inner join departamento d
on f.id_departamento = d.id_departamento
where f.nome_funcionario = p_nome;

RETURN v_depto;
END;

Explicando o código:

A função recebe como parâmetro de entrada o nome do funcionário (parâmetro p_nome). Na cláusula WHERE do comando SELECT, o campo nome_funcionario da tabela funcionario é comparado com o parâmetro p_nome, ou seja o nome do funcionário passado como parâmetro.  

A função vai retornar o nome do departamento do funcionário que é um VARCHAR2 por isso a função tem um RETURN VARCHAR2. Assim como na declaração dos parâmetros, não deve ser colocado o tamanho da cadeia de caracteres.

A variável v_depto recebe o nome do departamento do funcionário em INTO v_depto. O conteúdo desta variável é retornado em RETURN v_depto. 

Chamada da função: a chamada da função retorna_departamento é atribuída a variável v_nome no bloco PL/SQL anônimo.

DECLARE
  v_nome VARCHAR2(30);
BEGIN
  v_nome:= retorna_departamento('Pedro');
  DBMS_OUTPUT.PUT_LINE('Nome do Departamento:'||v_nome);
END;
</pre>

<pre>
  2.6 Cursor
Quando o Oracle executa uma consulta ele utilizada uma área da Memória para colocar o resultado desta consulta. Para recuperar cada uma das linhas do resultado utilizamos cursores. Existem dois tipos de cursores, implícitos e explícitos. Para qualquer comando DML (e SELECT que retorna uma única linha) o Oracle implicitamente abre um cursor chamado SQL. A cláusula INTO pode ser usado no SELECT apenas nas consultas que retornam uma única linha, nas consultas que retornam uma linha ou mais devemos utilizar cursores explícitos. Os cursores podem ser utilizados em qualquer tipo de bloco PL/SQL (anônimo, procedure, function e trigger).



Declaração de cursor explícito
CURSOR cursor_name [(parameter[, parameter]...)]
[RETURN return_type] IS select_statement;

Exemplo: Recuperar o código, nome e salário de todos os funcionários da empresa. Neste caso não podemos utilizar o INTO pois o SELECT pode retornar mais de uma linha.

CURSOR c_funcinario IS
SELECT id_funcionario, nome_funcionario, salario 
FROM funcionario;



Operações associadas a cursores

Open: Executa a consulta associada ao cursor e armazena o resultado na memória cujo início é apontado pelo cursor.

open <nome-cursor>

Fetch: Recupera uma linha do resultado. Transfere os seus valores para as variáveis e avança o cursor para a próxima linha.

Sintaxe:

fetch <nome-cursor> into <variáveis>

Close: Desativa o cursor e libera os dados da área temporária de memória.



Atributos do cursor
%ISOPEN - Retorna verdadeiro se o cursor estiver aberto
%NOTFOUND - Retorna verdadeiro se o FETCH mais recente não retornou nenhuma linha
%FOUND - Retorna verdadeiro se o FETCH mais recente retornou uma linha
%ROWCOUNT - Retorna o número total de linhas recuperadas até o momento
</pre>

<pre>
  2.6.1 Exemplo
Neste exemplo criamos um bloco PL/SQL anônimo com um cursor explícito chamado c_funcionario. Este cursor recupera o nome do funcionario e o salario de todos os funcionários da tabela funcionario. Como a tabela pode ter várias linhas não seria possível utilizar o SELECT .. INTO, então a solução é criar um cursor explícito. 

DECLARE
CURSOR c_funcionario IS
SELECT nome_funcionario, salario FROM Funcionario;
v_nome_funcionario funcionario.nome_funcionario%TYPE;

v_salario funcionario.salario%TYPE;
BEGIN
OPEN c_funcionario;
LOOP
FETCH c_funcionario INTO v_nome_funcionario,v_salario;
IF c_funcionario%NOTFOUND
THEN -- se encontrar o fim do cursor
EXIT;
END IF;
DBMS_OUTPUT.PUT_LINE(v_nome_funcionario);
DBMS_OUTPUT.PUT_LINE(v_salario);
END LOOP;
CLOSE c_funcionario;
END;

Explicando o código
 
CURSOR c_funcionario IS
SELECT nome_funcionario, salario 
FROM Funcionario;

v_nome_funcionario funcionario.nome_funcionario%TYPE;
v_salario funcionario.salario%TYPE;

Declara o cursor explícito c_funcionario e as variáveis v_nome e v_salario que receberão respectivamente o nome do funcionário (nome_funcionario) e o salário (salario), campos da cláusula SELECT. A variável v_nome é do mesmo tipo (%type) da coluna nome_funcionario da tabela funcionario (funcionario.nome_funcionario%TYPE), mas esta variável também poderia ser declara como um VARCHAR2(40) que é o tipo da coluna nome_funcionario na tabela funcionario. A variável v_salario é do mesmo tipo (%type) da coluna salario da tabela funcionario (funcionario.salario%TYPE), mas poderia ter sido declara como um NUMBER que o tipo da coluna salario na tabela funcionario. 

OPEN c_funcionario, o comando OPEN executa a consulta associada ao cursor e coloca o resultado em uma área temporária na memória. 
FETCH c_funcionario INTO v_nome_funcionario,v_salario; Analisando o código acima é possível verificar que o FETCH está dentro de um laço de repetição (LOOP ... END LOOP) pois o FETCH pega cada uma das linhas do resultado, se por exemplo o select retornar 20 linhas o FETCH precisa ser executado 20 vezes. O valor das colunas nome_funcionario e salario são transferidos para as variáveis v_nome e v_salario respectivamente a cada repetição (FETCH c_funcionario INTO v_nome_funcionario,v_salario).

IF c_funcionario%NOTFOUND
THEN -- se encontrar o fim do cursor
EXIT;
END IF;

O teste acima é executado dentro do laço de repetição logo depois do comando FETCH . Se o FETCH for executado e não retornar nenhuma linha (c_funcionario%NOTFOUND) significa que todas as linhas do resultado foram recuperadas e o laço de repetição pode ser encerrado (EXIT).
Depois que o laço de repetição for encerrado e todas as linhas forem recuperadas o cursor pode ser fechado (CLOSE c_funcionario)
</pre>

<pre>
  2.6.2 FOR LOOP
O comando FOR LOOP pode ser utilizado ao invés dos comandos OPEN, FETCH e CLOSE. Na verdade o FOR LOOP executa as 3 operações de forma implícita simplificando o código.

Exemplo1: Criar um bloco PL/SQL anônimo para recuperar o nome e o salário de todos os funcionários do departamento 1.

DECLARE
CURSOR c_funcionario IS
SELECT nome_funcionario,salario
FROM funcionario f
WHERE f.id_departamento =1;
BEGIN
/* FOR record_name IN cursor_name */
/* For open,fetch e close implícito */
FOR r_funcionario IN c_funcionario LOOP
DBMS_OUTPUT.PUT_LINE(r_funcionario.nome_funcionario);
DBMS_OUTPUT.PUT_LINE(r_funcionario.salario);
END LOOP; 
END;

/*  */ é comentário

Explicando o código:
O cursor é declarado em CURSOR com o nome c_funcionario.
No bloco principal do bloco PL/SQL o comando FOR LOOP é utilizado. r_funcionario é uma declaração implícita de uma variável registro que vai conter todos os campos da cláusula SELECT, neste caso nome_funcionario e salario. No comando FOR o IN c_funcionario é o nome do nosso CURSOR. É possível observar que não são utilizados os comandos OPEN, FETCH e CLOSE pois estas operações são executadas implicitamente pelo comando FOR LOOP. 
Dentro do comando FOR o PUT_LINE imprime o nome do funcionário (r_funcionario.nome_funcionario) e o salário (r_funcionario.salario).

Exemplo2: Neste exemplo vamos criar uma procedure que recupera o nome e o salário dos funcionários de um determinado departamento. O id do departamento é determinado por uma variável e o cursor é executado mais de uma vez, uma para cada valor de id_departamento.

CREATE OR REPLACE PROCEDURE consulta_funcionario IS
v_id_departamento NUMBER; -- deve ser declarado antes do cursor
CURSOR c_funcionario IS
SELECT nome_funcionario, salario
FROM Funcionario
WHERE id_departamento = v_id_departamento;
BEGIN
v_id_departamento:=1;
DBMS_OUTPUT.PUT_LINE('Departamento = 1 ');
FOR r_funcionario IN c_funcionario LOOP
DBMS_OUTPUT.PUT_LINE(r_funcionario.nome_funcionario||' '|| r_funcionario.salario); 
END LOOP;
v_id_departamento:=2;
DBMS_OUTPUT.PUT_LINE('Departamento = 2');
FOR r_funcionario IN c_funcionario LOOP 
DBMS_OUTPUT.PUT_LINE(r_funcionario.nome_funcionario||' '|| r_funcionario .salario); 
END LOOP;
 END;﻿

Explicando o código:

 Na declaração do cursor utilizamos a variável v_id_departamento na cláusula WHERE para recuperar os funcionários onde id_departamento é igual ao conteúdo da variável v_id_departamento. 

 A varíável v_id_departamento começa recebendo o valor 1 (v_id_departamento := 1). Quando o primeiro FOR LOOP for executado o SELECT associado ao cursor será executado para os fucionários do departamento 1.

  Depois que o cursor é executado para o departamento 1 a variável v_id_deptarmento recebe o valor 2 (v_id_departamento :=2) e o cursor é executado novamente (segundo FOR LOOP) agora para o departamento 2.

Exemplo3: Neste exemplo criamos um bloco PL/SQL anônimo para recuperar os dados de todos os funcionários. Não foi feita a declaração do cursor na seção DECLARE pois o SELECT foi colocado dentro do comando FOR LOOP. Esta estrutura não é recomenda se o a consulta for mais complexa pois o código pode ficar confuso com uma consulta muito grande no comando FOR LOOP.
A seção DECLARE não foi utilizada no bloco PL/SQL pois não temos nenhuma variável neste bloco PL/SQL.


BEGIN
FOR r_funcionario IN (SELECT * FROM funcionario) LOOP
DBMS_OUTPUT.PUT_LINE(r_funcionario.nome_funcionario||' '|| r_funcionario .salario); 
END LOOP;
END;
</pre>

<pre>
  2.6.3 Passando parâmetro para cursores
É possível passar parâmetros para os cursores, assim o parâmetro pode ser utilizado na cláusula WHERE para definir o critério da consulta. O valor do parâmetro é definido na utilização do cursor.

Exemplo: Bloco PL/SQL anônimo com um select associado a um cursor que recebe como parâmetro o salário e faz uma consulta que retorna o nome, id do departamento e salário dos funcionários cujo salário é maior do que o valor passado como parâmetro.

DECLARE
CURSOR c_funcionario (p_salario number) IS
SELECT nome_funcionario, id_departamento, salario 
FROM Funcionario
WHERE salario > p_salario;

BEGIN 

FOR r_funcionario IN c_funcionario(1000) LOOP
DBMS_OUTPUT.PUT_LINE(r_funcionario.nome_funcionario||' r_funcionario.salario); 
END LOOP; 

FOR r_funcionario IN c_funcionario(3000) LOOP
DBMS_OUTPUT.PUT_LINE(r_funcionario.nome_funcionario||' r_funcionario.salario); 
END LOOP; 

END;

Explicando o código: o cursor é executado duas vezes no bloco PL/SQL. O primeiro FOR LOOP executado a consulta associada ao cursor com o parâmetro 1000, portanto vai retornar os dados dos funcionários cujo salário é maior do que 1000. O segundo FOR LOOP executa o cursor com o parâmetro 3000 retornando os dados dos funcionários cujo salário é maior do que 3000.
</pre>

<pre>
  2.7 Desafio 4
Desafio: Neste desafio você deve utilizar um cursor explícito. Fazer um procedimento que escreva na tela as seguintes informações dos funcionários de um determinado departamento: o nome do funcionário, cargo e salário. (o id do departamento deve ser passado como parâmetro)
</pre>

<pre>
  2.7.1 Solução do Desafio 4

CREATE OR REPLACE PROCEDURE retorna_func_depto (p_id_departamento IN funcionario.id_departamento%type)
IS

CURSOR c_func_cargo IS
SELECT nome_funcionario, nome_cargo,salario
FROM funcironario f inner join cargo c
on f.id_cargo = c.id_cargo
where f.id_departamento = p_id_departamento;

BEGIN

FOR res IN c_func_cargo LOOP
DBMS_OUTPUT.PUT_LINE(res.nome_funcionario||' ' ||res.nome_cargo||' ' ||res.salario);
END LOOP;

END;

Explicando o código: O SELECT associado ao cursor faz um join entre as tabelas funcionario e cargo pois queremos retornar o nome, salario que estão na tabela funcionario e o cargo deste funcionário que está na tabela cargo. As tabelas são ligadas pelo id_cargo (ON f.id_cargo=c.id_cargo). Serão recuperados os dados dos funcionários que são do departamento cujo id é passado como parâmetro (WHERE f.id_departamento = p_id_departamento). 
O FOR LOOP faz o open,fetch e close do cursor de forma implícita, assim como a variável res tem declaração implícita (não precisa ser declara explicitamente na seção de declaração de variáveis) e só pode ser utilizada dentro do FOR LOOP. A variável res é um registro com os campos nome_funcionario, nome_cargo, salario que são os campos do select (SELECT nome_funcionario, nome_cargo,salario). Para imprimir o nome do funcionário é necessário colocar a variável res, um ponto e depois o nome do campo (res.nome_funcionario).


Versão 2: 
CREATE OR REPLACE PROCEDURE retorna_func_depto (p_id_departamento IN funcionario.id_departamento%type) IS

CURSOR c_func_cargo IS
SELECT nome_funcionario, nome_cargo,salario
FROM Funcionario f inner join cargo c
on f.id_cargo = c.id_cargo
WHERE f.id_departamento = p_id_departamento;

r_fc c_func_cargo%rowtype;

BEGIN

open c_func_cargo;
LOOP
FETCH c_func_cargo INTO r_fc;
IF c_func_cargo%NOTFOUND
THEN -- se encontrar o fim do cursor
EXIT;
END IF;
DBMS_OUTPUT.PUT_LINE(r_fc.nome_funcionario||' ' ||r_fc.nome_cargo||' ' ||r_fc.salario);
END LOOP;
CLOSE c_func_cargo;

﻿END;


Explicando o código: A diferença desta versão para a anterior é que os comandos OPEN, FETCH e CLOSE são explícitos pois não está sendo utilizado o comando FOR LOOP que realiza estas operações de forma implícita. Neste caso o comando FETCH está dentro de um laço de repetição pois deve ser executado uma vez para cada uma das linhas do resultado. A variável r_fc é declarada antes do BEGIN e é um registro com o mesmo tipo da linha (rowtype) do cursor c_func_cargo, ou seja, um registro com os campos do select (nome_funcionario, nome_cargo,salario). Depois de utilizado o cursor deve ser fechado para que a área de memória que contém o resultado da consulta seja liberada. O CLOSE c_func_cargo é executado depois do faço de repetição, depois do END LOOP.
</pre>

<pre>
  2.8 Teste seus conhecimentos
Agora que você já explorou sobre o curso, vamos testar seus conhecimentos!

É importante que você faça com calma e atenção. Após enviar sua resposta definitivamente, você poderá conferir seus acertos e visualizar a correção das questões. E não se preocupe em anotar tudo, pois as questões ficarão disponíveis após respondê-las, com as respostas que você escolheu.

Quantidade de questões apresentadas: 10
Exibição das questões: em página única
Quantidade de tentativas permitidas: 3
Tempo estimado para realizar a tentativa: 20 a 40 minutos
Método de avaliação: nota mais alta
Bons estudos!
</pre>